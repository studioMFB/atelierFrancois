ModelViewer.vue
<script setup lang="ts">
import { computed, reactive, ref, watch, type Ref } from 'vue';

import { Color, Vector2, Vector3 } from 'three';

import MainScene from "@/components/3D/MainScene.vue";
import WebGlRenderer from "@/components/3D/WebGlRenderer.vue";
import GameLoop from '@/components/3D/GameLoop.vue';
import ResizerComponent from '@/components/3D/ResizerComponent.vue';

import EffectComposer from '@/components/3D/EffectComposer.vue';

import RaycasterComponent from './RaycasterComponent.vue';

import PerspectiveCamera from '@/components/3D/PerspectiveCamera.vue';
import OrbitControls from '@/components/3D/OrbitControls.vue';
import TransformGizmos from '@/components/3D/TransformGizmos.vue';

import HemisphereLight from '@/components/3D/HemisphereLight.vue';
import PointLight from '@/components/3D/PointLight.vue';
import SpotLight from '@/components/3D/SpotLight.vue';

import GridHelper from '@/components/3D/GridHelper.vue';
import PlaneGeometry from '@/components/3D/PlaneGeometry.vue';

import { Model } from '../modelViewer/resources/model';


// GLTF //
const GLTF_TABLE = new URL('./../modelViewer/models/table/1/littlewood_furniture.gltf', import.meta.url).toString();
const GLTF_GARLIC = new URL('./../modelViewer/models/garlic/scene.gltf', import.meta.url).toString();
const GLTF_STONE = new URL('./../modelViewer/models/piedra/scene.gltf', import.meta.url).toString();

const GRID_SIZE = 5;
const GRID_RATIO = 0.5;
const GRID_CELL_SIZE = GRID_SIZE / GRID_RATIO;

const props = defineProps<{
    canvas?: HTMLCanvasElement
}>();

const canvas = computed(() => props.canvas) as Ref<HTMLCanvasElement>;
// const raycaster = ref<InstanceType<typeof RaycasterComponent>>();
// const modelsPool = reactive([]) as Model[];

// watch(() => raycaster.value?.modelsPool, (_modelsPool?: Model[]) => {
//     if (_modelsPool)
//         modelsPool.splice(0, modelsPool.length, ..._modelsPool); // to keep reactivity
// },
//     { immediate: true, deep: true }
// );
</script>

<template>
    <MainScene :colour="new Color(0xded6d8)">
        <!-- <PerspectiveCamera :position="new Vector3(2.0, 2.7, 0.19)" :zoom="1.5"> -->
        <PerspectiveCamera :position="new Vector3(4.4, 2.7, 2.0)" :zoom="1.5">
            <template v-slot:orbitControl>
                <OrbitControls :canvas="canvas">
                    <TransformGizmos :canvas="canvas">
                        <RaycasterComponent ref="raycaster" :canvas="canvas"></RaycasterComponent>
                    </TransformGizmos>
                </OrbitControls>
            </template>
            <template v-slot:webGlRenderer>
                <WebGlRenderer :canvas="canvas">
                    <template v-slot:GameLoop>
                        <GameLoop></GameLoop>
                    </template>
                    <template v-slot:EffectComposer>
                        <EffectComposer></EffectComposer>
                    </template>
                            <template v-slot:ResizerComponent>
                            <ResizerComponent></ResizerComponent>
                            </template>
                </WebGlRenderer>
            </template>
        </PerspectiveCamera>

        <HemisphereLight :sky-colour="new Color(0xffffff)" :ground-colour="new Color(0xffffff)" :intensity="1.05">
        </HemisphereLight>
        <SpotLight :colour="new Color(0xffffff)" :position="new Vector3(5, 9, 7)"></SpotLight>

        <PointLight :colour="new Color(0xff0040)" :position="new Vector3(0, 10.5, 2)"></PointLight>
        <PointLight :colour="new Color(0x0040ff)" :position="new Vector3(0, 4.5, 2)"></PointLight>
        <PointLight :colour="new Color(0x80ff80)" :position="new Vector3(2, 9.5, -2)"></PointLight>
        <PointLight :colour="new Color(0xffaa00)" :position="new Vector3(-2, 6.5, 2)"></PointLight>

        <GridHelper :size="GRID_SIZE" :divisions="GRID_CELL_SIZE" :colour1="new Color(0x888888)"
            :colour2="new Color(0x888888)">
        </GridHelper>
        <PlaneGeometry :dimension="new Vector2(GRID_SIZE, GRID_SIZE)" :segment="new Vector2(1, 1)"
            :position="new Vector3(0, 0, 0)"></PlaneGeometry>

        <!-- <ModelAsset name="table" :position="new Vector3(0, 0, -1)" :scale-ratio="1" :gltf-url="GLTF_TABLE"></ModelAsset> -->
        <!-- <ModelAsset name="garlic" :position="new Vector3(0, 0, 0)" :scale-ratio="10" :gltf-url="GLTF_GARLIC"></ModelAsset> -->
        <!-- <ModelAsset name="stone" :position="new Vector3(1, 0, 1)" :scale-ratio="1" :gltf-url="GLTF_STONE"></ModelAsset> -->
    </MainScene>
</template>

MainScene.vue
<script setup lang="ts">
import { computed, provide } from 'vue';

import { Color, Scene, Fog, type Object3DEventMap, Group } from 'three';
import type { Model } from '../modelViewer/resources/model';


// GLTF //
const GLTF_TABLE = new URL('./../modelViewer/models/table/1/littlewood_furniture.gltf', import.meta.url).toString();
const GLTF_GARLIC = new URL('./../modelViewer/models/garlic/scene.gltf', import.meta.url).toString();
const GLTF_STONE = new URL('./../modelViewer/models/piedra/scene.gltf', import.meta.url).toString();


const props = defineProps<{
    colour: Color,
}>();

provide("allModelsArray", [] as Group<Object3DEventMap>[]);

const colour = computed(() => props.colour);

const scene = new Scene();
scene.name = "main_scene";
scene.background = new Color(colour.value);
scene.fog = new Fog(colour.value, 200, 1000);

provide("MainScene", scene);
provide("modelsPool", [] as Model[]);
</script>

<template>
    <slot></slot>
</template>

PerspectiveCamera.vue
<script setup lang="ts">
import { computed, provide } from 'vue';

import { PerspectiveCamera, Vector3 } from 'three';


const props = defineProps<{
    position: Vector3,
    zoom?: number
}>();

const position = computed(() => props.position);
const zoom = computed(() => props.zoom);

const camera = new PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 100);
camera.name = "main_perspective_camera";
camera.position.set(position.value.x, position.value.y, position.value.z);
if (zoom.value)
    camera.zoom = zoom.value;

// Adjust the camera tilt
// camera.rotation.x = -Math.PI / 4; // Tilt the camera down by 30 degrees (Ï€/6 radians)

provide("PerspectiveCamera", camera);
</script>

<template>
    <!-- <slot></slot> -->
    <!-- <slot name="orbitControl"></slot> -->
    <slot name="webGlRenderer"></slot>
</template>

OrbitControls.vue
<script setup lang="ts">
import { computed, inject, provide } from 'vue';

import { PerspectiveCamera } from 'three';
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";


const props = defineProps<{
    canvas?: HTMLElement
}>();

const camera = computed(() => inject("PerspectiveCamera") as PerspectiveCamera)
const canvas = computed(() => props.canvas)

const controls = new OrbitControls(camera.value, canvas.value);
controls.enabled = true;
controls.autoRotate = false;
controls.autoRotateSpeed = 1;
        
controls.enableDamping = true;
controls.enableZoom = true;
controls.enablePan = true;
        
controls.minDistance = 2;
controls.maxDistance = 10;
controls.target.set( 0, 0, - 0.2 );
controls.update();

provide("OrbitControls", controls);
</script>

<template>
    <slot></slot>
</template>

TransformGizmos.vue
<script setup lang="ts">
import { computed, inject, provide, ref, type Ref } from 'vue';

import { PerspectiveCamera, Scene } from 'three';
import { TransformControls, TransformControlsGizmo } from 'three/examples/jsm/controls/TransformControls.js';


const props = defineProps<{
    canvas?: HTMLCanvasElement
}>();

const canvas = computed(() => props.canvas) as Ref<HTMLCanvasElement>;;
const scene = ref(inject("MainScene")) as Ref<Scene>;
const camera = ref(inject("PerspectiveCamera")) as Ref<PerspectiveCamera>;

const transformControls = new TransformControls(camera.value, canvas.value);
transformControls.name = "transform_controls_gizmos";

transformControls.setMode('translate');

scene.value.add(transformControls);

// FIND A FIX TO ADJUST GIZMO POSITION FOR ALL MODELS
// Adjust gizmo pos to be in centre of Table model.
transformControls.position.x -= .1;
transformControls.position.y += .6;

// Main gizmo, arrows and squares
(transformControls.children[0] as TransformControlsGizmo).gizmo.translate.traverse((child: any) => {
    if (child.isMesh) {
        // The square in the centre of the gizmos,
        // with which you can move the model in any direction.
        if (child.name === 'XYZ') {
            (child.material as THREE.MeshBasicMaterial).color.set(0x0e73e6);
            (child.material as THREE.MeshBasicMaterial).opacity = 0.5;
        }
        else {
            (child.material as THREE.MeshBasicMaterial).visible = false;
        }
    }
});

// Pickers
// Not sure it does much.
(transformControls.children[0] as TransformControlsGizmo).picker.translate.traverse((child: any) => {
    if (child.isMesh) {
        (child.material as THREE.MeshBasicMaterial).visible = false;
    }
});

// Helper transform lines axis
(transformControls.children[0] as TransformControlsGizmo).helper.translate.traverse((child: any) => {
    if (child.isLine) {
        (child.material as THREE.MeshBasicMaterial).visible = false;
    }
});

provide("TransformGizmos", transformControls);
</script>

<template>
    <slot></slot>
</template>

RaycasterComponent.vue
<script setup lang="ts">
import { computed, inject, onMounted, reactive, ref, type Ref } from 'vue';
import { Color, Group, type Intersection, Mesh, MeshToonMaterial, Object3D, type Object3DEventMap, PerspectiveCamera, Raycaster, Scene, Vector2, Vector3 } from 'three';
import { TransformControls } from 'three/examples/jsm/controls/TransformControls.js';

import { Model } from '@/components/modelViewer/resources/model';
import type { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';


// Colour //
const COLOUR_SELECTED = '#f47653';
const COLOUR_UNSELECTED = '#e2eab8';
// GLTF //
const GLTF_TABLE = new URL('./../modelViewer/models/table/1/littlewood_furniture.gltf', import.meta.url).toString();
const GLTF_GARLIC = new URL('./../modelViewer/models/garlic/scene.gltf', import.meta.url).toString();
const GLTF_STONE = new URL('./../modelViewer/models/piedra/scene.gltf', import.meta.url).toString();

const props = defineProps<{
    canvas: HTMLCanvasElement
}>();

const canvas = computed(() => props.canvas) as Ref<HTMLCanvasElement>;;
const scene = ref(inject("MainScene")) as Ref<Scene>;
const camera = ref(inject("PerspectiveCamera")) as Ref<PerspectiveCamera>;
const transformControlsGizmos = ref(inject("TransformGizmos")) as Ref<TransformControls>;
const controls = ref(inject("OrbitControls")) as Ref<OrbitControls>;

const allModelsArray = inject("allModelsArray", [] as Group<Object3DEventMap>[]);

const raycaster = new Raycaster();
const pointer = new Vector2();
let intersect: Intersection<Object3D<Object3DEventMap>>;
let intersectedGroupObject: Group<Object3DEventMap>;

// const modelsPool = reactive([]) as Model[];
const modelsPool = inject("modelsPool", [] as Model[]);

// defineExpose({
//     modelsPool
// });

let isLeftMouseButtonDown = false;
let isSelected = false;
let rotationDelta = 0;

// GRID in meters
const GRID_SIZE = 5;
const gridLimits = {
    minX: -GRID_SIZE / 2,  // Minimum X value
    maxX: GRID_SIZE / 2,   // Maximum X value
    minY: 0,    // Minimum Y value (assuming Y is up)
    maxY: 0,   // Maximum Y value
    minZ: -GRID_SIZE / 2,  // Minimum Z value
    maxZ: GRID_SIZE / 2    // Maximum Z value
};

function findModelParent(mesh: any): Group<Object3DEventMap> | null {
    // If the mesh has no parent, return null
    if (!mesh.parent) {
        return null;
    }

    const rootName = 'root_model';
    // If the parent is an instance of GameObject, return it
    if (mesh.parent.name === rootName) {
        return mesh.parent as Group<Object3DEventMap>;
    }

    // Otherwise, recursively call the function with the parent as the argument
    return findModelParent(mesh.parent);
}

// RAYCASTER //
function intersection(): boolean {
    if (!raycaster || allModelsArray.length < 1 || !allModelsArray.every(obj => obj))
        return false;

    const intersects = raycaster.intersectObjects(allModelsArray, true); // true for recursive checks

    if (intersects.length > 0) {
        intersect = intersects[0];
        intersectedGroupObject = findModelParent(intersect.object as Mesh)!;
        return true;
    }
    else {
        return false;
    }
}

function restrictPositionToBoundaries(position: Vector3) {
    return new Vector3(
        Math.max(gridLimits.minX, Math.min(gridLimits.maxX, position.x)),
        gridLimits.minY, // Fixed to ground level
        Math.max(gridLimits.minZ, Math.min(gridLimits.maxZ, position.z))
    );
}

function restricMoveToBoundaries() {
    if (intersectedGroupObject) {
        intersectedGroupObject.position.copy(restrictPositionToBoundaries(intersectedGroupObject.position));
    }
}

function updatePointerMode(event: PointerEvent) {
    event.preventDefault();

    pointer.x = (event.clientX / canvas.value.clientWidth) * 2 - 1;
    pointer.y = -(event.clientY / canvas.value.clientHeight) * 2 + 1;

    try {
        if (raycaster && pointer && camera.value)
            raycaster.setFromCamera(pointer, camera.value);
    }
    catch (e: any) {
        console.error("Error setting raycaster:", e);
    }
}

const models = reactive({
    table: setupModel("table", new Vector3(-0.5, 0, -0.5), 1, GLTF_TABLE),
    garlic: setupModel("garlic", new Vector3(-0.5, 0, -0.5), 10, GLTF_GARLIC),
    stone: setupModel("stone", new Vector3(-0.5, 0, -0.5), 0.4, GLTF_STONE),
});

function setupModel(name: string, position: Vector3, scale: number, url: string) {
    return { name, position, scale, url };
}

function addModelToScene(modelKey: keyof typeof models) {
    const model = models[modelKey];

    const modelInstance = new Model(model.name, model.position, model.scale, model.url);

    modelInstance.initMesh().then((modelScene: Group<Object3DEventMap>) => {
        scene.value.add(modelScene); // to be view in the scene
        modelsPool.push(modelInstance); // For Animation update
        allModelsArray.push(modelScene); // For Raycasting
    });
}

function addModelToSceneAtCursor(modelKey: keyof typeof models) {
    const model = models[modelKey];

    if (!intersection()) return; // Ensure there is a valid intersection point.

    // Restrict the intersection point to grid boundaries.
    const spawnPosition = restrictPositionToBoundaries(intersect.point);

    // Create a new model instance with the intersection point as the position.
    const modelInstance = new Model(model.name, spawnPosition, model.scale, model.url);

    modelInstance.initMesh().then((modelScene: Group<Object3DEventMap>) => {
        scene.value.add(modelScene); // to be view in the scene
        modelsPool.push(modelInstance); // For Animation update
        allModelsArray.push(modelScene); // For Raycasting
    });
}


function handlePointerEvent(event: PointerEvent) {
    updatePointerMode(event);

    if (event.type === 'pointermove') {
        if (intersection()) {
            // console.log("Object intersected:", intersectedGroupObject);
            attachGizmoToObject(intersectedGroupObject);
        }

        restricMoveToBoundaries();
    }
    else if (event.type === 'pointerdown') {
        if (keyState.keyT) addModelToScene("table");
        if (keyState.keyG) addModelToScene("garlic");
        if (keyState.keyR) addModelToScene("stone");
    }
}

function onWheel(event: WheelEvent) {
    // Rotate the model by increment of 90'.
    if (isLeftMouseButtonDown) {
        // Determine the scroll direction and amount
        const delta = Math.sign(event.deltaY);
        // Define the rotation speed
        const rotationSpeed = Math.PI / 2;
        // Update the rotation delta
        rotationDelta = delta * rotationSpeed;

        intersectedGroupObject.rotation.y += rotationDelta;
    }
}

function changeColour(colour: string) {
    if (!intersectedGroupObject)
        return;

    intersectedGroupObject.children.forEach(child => {
        const c = child as Mesh;
        if (!c.name.toLowerCase().includes("outline")) {
            const mat = (c.material as MeshToonMaterial);

            if (mat) {
                (c.material as MeshToonMaterial).color = new Color(colour);
                return;
            }
        }
    });
}

const keyState = reactive({
    keyT: false,
    keyG: false,
    keyR: false
});

function handleKeyEvent(event: KeyboardEvent, isDown: boolean) {
    switch (event.code) {
        case 'KeyT': keyState.keyT = isDown; break;
        case 'KeyG': keyState.keyG = isDown; break;
        case 'KeyR': keyState.keyR = isDown; break;
    }
}

function attachGizmoToObject(targetObject: Object3D) {
    if (!targetObject || targetObject.name === "Main_Plane") {
        transformControlsGizmos.value.detach();
        return;
    }

    transformControlsGizmos.value.attach(targetObject);
    isSelected = true;
    changeColour(COLOUR_SELECTED);
}

function detachGizmo() {
    transformControlsGizmos.value.detach();
    isSelected = false;
    changeColour(COLOUR_UNSELECTED);
}

function setupEventListeners(): void {
    // Pointer
    document.addEventListener('pointermove', (e: PointerEvent) => handlePointerEvent(e));
    document.addEventListener('pointerdown', (e: PointerEvent) => handlePointerEvent(e));

    document.addEventListener('wheel', (e: WheelEvent) => { onWheel(e) });

    // Keys
    document.addEventListener('keydown', (e) => handleKeyEvent(e, true));
    document.addEventListener('keyup', (e) => handleKeyEvent(e, false));

    canvas.value.addEventListener("pointerup", detachGizmo);

    transformControlsGizmos.value.addEventListener("mouseDown", () => {
        if (controls.value) controls.value.enabled = false;
        isLeftMouseButtonDown = true;
    });

    transformControlsGizmos.value.addEventListener("mouseUp", () => {
        if (controls.value) controls.value.enabled = true;
        isLeftMouseButtonDown = false;
    });
}

onMounted(() => {
    setupEventListeners();

    // To populate the scene initially
})
</script>

<template>
    <slot></slot>
</template>

WebGlRenderer.vue
<script setup lang="ts">
import { computed, inject, provide } from 'vue';

import { PCFSoftShadowMap, PerspectiveCamera, Scene, Vector2, WebGLRenderer } from 'three';
import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';


const props = defineProps<{
    canvas?: HTMLCanvasElement
}>();

const canvas = computed(() => props.canvas);
const scene = computed(() => inject("MainScene") as Scene);
const camera = computed(() => inject("PerspectiveCamera") as PerspectiveCamera);

const renderer = new WebGLRenderer({ antialias: true, canvas: canvas.value });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.type = PCFSoftShadowMap;
renderer.shadowMap.enabled = true;

const composer = new EffectComposer(renderer);
const outlinePass = new OutlinePass(new Vector2(window.innerWidth, window.innerHeight), scene.value, camera.value)

provide("WebGlrenderer", renderer);

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene.value, camera.value);
    // composer.render(); // Use composer instead of renderer
}

animate();
</script>

<template>
    <!-- <slot :outlinePass="outlinePass" :composer="composer"></slot> -->
    <slot name="GameLoop"></slot>
    <slot name="EffectComposer"></slot>
    <slot name="ResizerComponent"></slot>
</template>

GameLoop.vue
<script setup lang="ts">

import { Clock, Scene, WebGLRenderer, Vector3, PerspectiveCamera, Group, type Object3DEventMap, Box3 } from "three";
import { Model } from "@/components/modelViewer/resources/model";
import { computed, inject, provide, reactive, ref, toRefs, watch, watchEffect, type Ref } from "vue";


const GRID_SIZE = 5;
const gridLimits = {
  minX: -GRID_SIZE / 2,  // Minimum X value
  maxX: GRID_SIZE / 2,   // Maximum X value
  minY: 0,    // Minimum Y value (assuming Y is up)
  maxY: 0,   // Maximum Y value
  minZ: -GRID_SIZE / 2,  // Minimum Z value
  maxZ: GRID_SIZE / 2    // Maximum Z value
};

// const props = defineProps<{
//   modelsPool: Model[];
// }>();

// const modelsPool = reactive(props.modelsPool);
const modelsPool = inject("modelsPool", [] as Model[]);

// watch(() => props.modelsPool, (_modelsPool: Model[]) => {
//   // console.log("Gameloop => watch => newFurnitureArray ", newFurnitureArray);
//   modelsPool.splice(0, modelsPool.length, ..._modelsPool); // to keep reactivity
//   // checkCollision(furnitureArray.value);
//   // start();
// });

const renderer = ref(inject("WebGlrenderer")) as Ref<WebGLRenderer>;
const scene = ref(inject("MainScene")) as Ref<Scene>;
const camera = ref(inject("PerspectiveCamera")) as Ref<PerspectiveCamera>;
const clock = new Clock();
const updatables: any[] = [];

provide("GameLoopUpdatables", updatables)

start();

// function addToUpdate(object: any) {
//   updatables.push(object);
// }

function checkCollision(furnitureArray: Model[]) {
  // console.log("GameLoop => checkCollision => furnitureArray ", furnitureArray);

  if (furnitureArray.length == 0 || !furnitureArray[0].modelScene)
    return;

  for (let i = 0; i < furnitureArray.length; ++i) {
    if (!furnitureArray[i].modelScene)
      return;

    // this.restricMoveToBoundaries(furnitureArray[i].scene, furnitureArray[i].boundingBox);
    for (let j = 0; j < furnitureArray.length; ++j) {
      if (!furnitureArray[j].modelScene)
        return;

      // Don't collide with itself.
      if (j == i)
        continue;

      if (!furnitureArray[i].boundingBox)
        return;

      if (furnitureArray[i].boundingBox?.intersectsBox(furnitureArray[j].boundingBox!)) {
        // Handle collision
        // console.log("GameLoop => checkCollision => resolveOverlap ");
        resolveOverlap(furnitureArray[i].modelScene!, furnitureArray[i].boundingBox!, furnitureArray[j].modelScene!, furnitureArray[j].boundingBox!);
      }
    }
  }
}

function resolveOverlap(object1: Group<Object3DEventMap>, box1: Box3, object2: Group<Object3DEventMap>, box2: Box3) {
  if (box1.intersectsBox(box2)) {
    // Calculate overlap on each axis
    const overlapX = Math.min(box1.max.x, box2.max.x) - Math.max(box1.min.x, box2.min.x);
    const overlapY = Math.min(box1.max.y, box2.max.y) - Math.max(box1.min.y, box2.min.y);
    const overlapZ = Math.min(box1.max.z, box2.max.z) - Math.max(box1.min.z, box2.min.z);

    // Determine the minimum overlap direction
    // const overlapMin = Math.min(overlapX, Math.min(overlapZ));
    const overlapMin = Math.min(overlapX, Math.min(overlapY, overlapZ));

    // Create a vector for the resolution movement
    const move = new Vector3();

    // Depending on the minimum overlap, move on the corresponding axis
    if (overlapMin === overlapX) {
      move.setX(overlapX * (object1.position.x > object2.position.x ? 1 : -1));
    }
    //  else if (overlapMin === overlapY) {
    //   move.setY(overlapY * (object1.position.y > object2.position.y ? 1 : -1));
    // move.setY(-1);
    // } 
    else { // overlapMin == overlapZ
      move.setZ(overlapZ * (object1.position.z > object2.position.z ? 1 : -1));
    }

    // object1.position.y = 0;
    // object2.position.y = 0;

    // Adjust the position to resolve the overlap
    object1.position.add(move.multiplyScalar(0.5)); // Adjusting both objects by half the overlap
    object2.position.sub(move.multiplyScalar(0.5));

    restricMoveToBoundaries(object1, box1);
    restricMoveToBoundaries(object2, box2);
  }
}

function restricMoveToBoundaries(object: Group<Object3DEventMap>, box: Box3) {
  // Constrain X position
  // object1.position.x = Math.max(gridLimits.minX, Math.min(gridLimits.maxX, object1.position.x));
  // object1.position.x = Math.max(gridLimits.minX, Math.min(gridLimits.maxX, box1.min.x));
  // object1.position.x = Math.min(gridLimits.maxX, box1.max.x) - Math.max(gridLimits.minX, box1.min.x);

  // Stop the lifting the model up.
  object.position.y = 0;

  // Constrain Z position
  // object1.position.z = Math.max(gridLimits.minZ, Math.min(gridLimits.maxZ, object1.position.z));
  // object1.position.z = Math.max(gridLimits.minZ, Math.min(gridLimits.maxZ, box1.min.z));
  // object1.position.z = Math.min(gridLimits.maxZ, box1.max.z) - Math.max(gridLimits.minZ, box1.min.z);

  object.position.x = Math.max(gridLimits.minX, Math.min(gridLimits.maxX, object.position.x));
  object.position.z = Math.max(gridLimits.minZ, Math.min(gridLimits.maxZ, object.position.z));
}

function start() {
  renderer.value.setAnimationLoop(() => {
    // console.log("Renderer => Start animation Loop", renderer.value);
    modelsPool.forEach((furniture: Model) => {
      const delta = clock.getDelta();
      furniture.tick(delta);
      checkCollision(modelsPool);
      // console.log("camera.position ", camera.value.position);
            
      // try{
        // if(renderer.value && scene.value && camera.value)
          // renderer.value.render(scene.value, camera.value);
        
          // Render using composer if using post-processing
          // composer.render();
        // }
        // catch(e:any){
        //     throw new Error(e);
        //   }
    });
  });
}

function stop() {
  renderer.value.setAnimationLoop(null);
}

function tick(delta?: number) {
  if (!delta) {
    delta = clock.getDelta();
  }

  for (const data of updatables) {
    data.tick(delta);
  }
}
</script>

<template>
  <slot></slot>
</template>

EffectComposer.vue
<script setup lang="ts">
import { computed, inject, ref, type Ref } from "vue";

import { Scene, WebGLRenderer, PerspectiveCamera, Vector2 } from "three";

import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { OutlinePass } from "three/examples/jsm/postprocessing/OutlinePass.js";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";

// const props = defineProps<{
//     outlinePass: OutlinePass;
//     composer: EffectComposer;
// }>();

// const outlinePass = ref(props.outlinePass);
// const composer = ref(props.composer);

const renderer = ref(inject("WebGlrenderer")) as Ref<WebGLRenderer>;
const scene = ref(inject("MainScene")) as Ref<Scene>;
const camera = ref(inject("PerspectiveCamera")) as Ref<PerspectiveCamera>;

const composer = new EffectComposer(renderer.value);
const renderPass = new RenderPass(scene.value, camera.value);
composer.addPass(renderPass);

const outlinePass = new OutlinePass(new Vector2(window.innerWidth, window.innerHeight), scene.value, camera.value);
composer.addPass(outlinePass);

outlinePass.edgeStrength = 3;
outlinePass.edgeGlow = 0.7;
outlinePass.edgeThickness = 1;
outlinePass.pulsePeriod = 2;
outlinePass.visibleEdgeColor.set('#ff0000'); // red color
outlinePass.hiddenEdgeColor.set('#190a05');
</script>

<template>
    <!-- <slot :outlinePass="outlinePass" :composer="composer"></slot> -->
     <slot></slot>
</template>

ResizerComponent.vue
<script setup lang="ts">
import { computed, inject, ref } from "vue";

import { PerspectiveCamera, WebGLRenderer } from "three";
import type { OutlinePass } from "three/examples/jsm/postprocessing/OutlinePass.js";
import type { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";


// const props = defineProps<{
//     outlinePass: OutlinePass;
//     composer: EffectComposer;
// }>();

const renderer = computed(() => inject("WebGlrenderer") as WebGLRenderer);
const camera = computed(() => inject("PerspectiveCamera") as PerspectiveCamera);

// const outlinePass = ref(props.outlinePass);
// const composer = ref(props.composer);

setSize();

window.addEventListener('resize', () => {
    setSize();
});

function setSize(): void {
    const width = window.innerWidth;
    const height = window.innerHeight;

    
    camera.value.updateProjectionMatrix();
    
    renderer.value.setSize(width, height);
    renderer.value.setPixelRatio(window.devicePixelRatio);
    
    // camera.value.aspect = window.innerWidth / window.innerHeight *.5;
    camera.value.aspect = width / height;
    camera.value.updateProjectionMatrix();

    renderer.value.setSize(width, height);
//     composer.value.setSize(width, height);
//     outlinePass.value.setSize(width, height);
}
</script>

<template>
    <slot></slot>
</template>

HemispherLight.vue
<script setup lang="ts">
import { computed, inject } from 'vue';

import { type ColorRepresentation, HemisphereLight, Scene, Vector3 } from 'three';


const props = defineProps<{
    position?: Vector3,
    skyColour?: ColorRepresentation,
    groundColour?: ColorRepresentation,
    intensity?: number
}>();

const scene = computed(() => inject("MainScene") as Scene);
const position = computed(() => props.position);
const skyColour = computed(() => props.skyColour);
const groundColour = computed(() => props.groundColour);
const intensity = computed(() => props.intensity);

const light = new HemisphereLight(skyColour.value, groundColour.value, intensity.value);

// console.log("HemisphereLight => light ", light.value);
scene.value.add(light);
</script>

<template>
    <slot></slot>
</template>

SpotLight.vue
<script setup lang="ts">
import { computed, inject } from 'vue';

import { type ColorRepresentation, Scene, SpotLight, Vector3 } from 'three';


const props = defineProps<{
    position?: Vector3,
    colour?: ColorRepresentation,
    intensity?: number
}>();

const scene = computed(() => inject("MainScene") as Scene);
const position = computed(() => props.position);
const colour = computed(() => props.colour);
const intensity = computed(() => props.intensity);

const light = new SpotLight(colour.value, intensity.value);
// light.castShadow = true;
// light.shadow.radius = 15;

light.angle = Math.PI / 5;
light.penumbra = 0.3;

if(position.value)
    light.position.set(position.value.x, position.value.y, position.value.z);

light.castShadow = true;

light.shadow.camera.near = 10;
light.shadow.camera.far = 200;
light.shadow.mapSize.width = 200;
light.shadow.mapSize.height = 200;
light.shadow.bias = - 0.005;
light.shadow.radius = 20;

scene.value.add(light);
</script>

<template>
    <slot></slot>
</template>

PointLight.vue
<script setup lang="ts">
import { computed, inject } from 'vue';

import { type ColorRepresentation, PointLight, Scene, Vector3 } from 'three';


const props = defineProps<{
    position?: Vector3,
    colour?: ColorRepresentation,
    intensity?: number
}>();

const scene = computed(() => inject("MainScene") as Scene);
const position = computed(() => props.position);
const colour = computed(() => props.colour);
const intensity = computed(() => props.intensity);

const light = new PointLight(colour.value, intensity.value);
const power = 700;
// const distance = 100;

if(position.value)
    light.position.set(position.value.x, position.value.y, position.value.z);

light.castShadow = false;
light.power = power;

scene.value.add(light);
</script>

<template>
    <slot></slot>
</template>

GridHelper.vue
<script setup lang="ts">
import { computed, inject } from 'vue';

import { type ColorRepresentation, GridHelper, Scene } from 'three';


const props = defineProps<{
    size?: number,
    divisions?: number,
    colour1?: ColorRepresentation,
    colour2?: ColorRepresentation,
}>();

const scene = computed(() => inject("MainScene") as Scene);
const size = computed(() => props.size);
const divisions = computed(() => props.divisions);
const colour1 = computed(() => props.colour1);
const colour2 = computed(() => props.colour2);

const grid = new GridHelper(size.value, divisions.value, colour1.value, colour2.value);

scene.value.add(grid);
</script>

<template>
    <slot></slot>
</template>

PlaneGeometry.vue
<script setup lang="ts">
import { computed, inject, onMounted} from 'vue';

import { Color, DoubleSide, ExtrudeGeometry, Group, Mesh, MeshBasicMaterial, MeshStandardMaterial, 
    PlaneGeometry, Scene, ShadowMaterial, Shape, Vector2, Vector3, type Object3DEventMap } from 'three';


const props = defineProps<{
    dimension: Vector2,
    segment: Vector2,
    position: Vector3,
}>();

const scene = computed(() => inject("MainScene") as Scene);
const dimension = computed(() => props.dimension);
const segment = computed(() => props.segment);
const position = computed(() => props.position);

const modelScene: Group<Object3DEventMap> = new Group<Object3DEventMap>();

function roundEdgedBox() {
    const w = 5.2;
    const d = 5.2;
    const r = 0.2;
    const h = 0.1;

    //Generate the rounded rect shape
    const shape = new Shape();

    shape.moveTo(-w / 2, -d / 2 + r);
    shape.lineTo(-w / 2, d / 2 - r);
    shape.absarc(-w / 2 + r, d / 2 - r, r, 1 * Math.PI, 0.5 * Math.PI, true);
    shape.lineTo(w / 2 - r, d / 2);
    shape.absarc(w / 2 - r, d / 2 - r, r, 0.5 * Math.PI, 0 * Math.PI, true);
    shape.lineTo(w / 2, -d / 2 + r);
    shape.absarc(w / 2 - r, -d / 2 + r, r, 2 * Math.PI, 1.5 * Math.PI, true);
    shape.lineTo(-w / 2 + r, -d / 2);
    shape.absarc(-w / 2 + r, -d / 2 + r, r, 1.5 * Math.PI, 1 * Math.PI, true);

    //This is the material that is used to stop the
    //lines in the back from showing
    const mat = new MeshBasicMaterial({
        color: new Color(0xe5e0d8),
        side: DoubleSide,
        depthTest: true,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1
    });

    const geom = new ExtrudeGeometry(shape, { depth: h, bevelEnabled: false });

    const mesh = new Mesh(geom, mat);
    mesh.rotateX(1.57);
    mesh.position.y = -0.01;

    scene.value.add(mesh);
}

function initMesh(isVisible: boolean, opacity: number, colour?: Color): void {
    // GROUND //
    const geometry: PlaneGeometry = new PlaneGeometry(dimension.value.x, dimension.value.y, segment.value.x, segment.value.y);
    geometry.rotateX(- Math.PI / 2);

    const material = new MeshStandardMaterial({
        color: colour || new Color(0xff0000),
        visible: isVisible,
        opacity: opacity,
    });
    const ground = new Mesh(geometry, material);
    ground.name = "Main_Plane";
    ground.receiveShadow = false;

    ground.position.set(position.value.x, position.value.y, position.value.z);

    // SHADOW GROUND //
    const shadowGround: Mesh = ground.clone();
    shadowGround.material = new ShadowMaterial({
        opacity: .5,
        color: "#888888",
        side: DoubleSide,
        transparent: true
    });

    shadowGround.receiveShadow = true;
    shadowGround.position.set(position.value.x + 0.01, position.value.y + 0.01, position.value.z + 0.01);

    roundEdgedBox();

    modelScene.add(ground);
    modelScene.add(shadowGround);

    scene.value.add(modelScene);

    // Update transforms for modelScene and its children
    modelScene.updateMatrixWorld(true);
}

initMesh(false, 1);

onMounted(() => {
    // For Raycasting
    const allModelsArray = inject("allModelsArray", [] as Group<Object3DEventMap>[]);
    allModelsArray.push(modelScene);
})
</script>

<template>
    <slot></slot>
</template>

ModelAsset.vue
<script setup lang="ts">
import { computed, inject } from 'vue';

import { Box3, BoxHelper, Color, Group, Mesh, MeshBasicMaterial, MeshStandardMaterial, MeshToonMaterial,
    type Object3DEventMap, PlaneGeometry, Scene, Vector3 } from 'three';
import { type GLTF, GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';


const props = defineProps<{
    name: string,
    position: Vector3,
    scaleRatio: number,
    gltfUrl: string,
}>();

const scene = computed(() => inject("MainScene") as Scene);
const name = computed(() => props.name);
const position = computed(() => props.position);
const scaleRatio = computed(() => props.scaleRatio);
const gltfUrl = computed(() => props.gltfUrl);

// Colour //
const COLOUR_SELECTED = '#f47653';
const COLOUR_UNSELECTED = '#e2eab8';

const allModelsArray = inject("allModelsArray", [] as Group<Object3DEventMap>[]);

let boundingBox: Box3;
let boxHelper: BoxHelper;
let modelScene: Group<Object3DEventMap>;

async function initMesh(scene: Scene, modelsArray: Group<Object3DEventMap>[]): Promise<void> {
    const loader = new GLTFLoader();

    const parameters = {
        color: new Color(0xe2eab8)
    }

    const matToon = new MeshToonMaterial(parameters);
    matToon.opacity = .005;
    const matColor = new MeshBasicMaterial({ color: 0x3c3c3c });

    loader.load(gltfUrl.value, (gltf: GLTF) => {

        modelScene = gltf.scene;

        gltf.scene.traverse((child: any) => {
            if (child.isMesh) {
                child.geometry.computeBoundingBox();
            }

            if (child.name.toLowerCase().includes("outline")) {
                child.material = matColor;
            }
            else {
                child.material = matToon;
                child.castShadow = true;
            }

            child.name += "-model";
        });

        modelScene.name = 'root_model_scene';
        modelScene.scale.multiplyScalar(scaleRatio.value);
        modelScene.position.set(position.value.x, position.value.y, position.value.z);

        // boxHelper = new BoxHelper(modelScene, 0xff0000);
        // boxHelper.name = 'boxHelper_model';
        // boundingBox = new Box3().setFromObject(boxHelper);
        // boxHelper.update();

        // If you want a visible bounding box
        scene.add(modelScene);
        // scene.add(this.scene, this.boxHelper);
        modelsArray.push(modelScene);
    });
}

// DEVELOPMENT ONLY
initMesh(scene.value, allModelsArray).then(() => {
    // GHOST //        
    const bboxSize = new Vector3(1.5, 0, 0.55);

    const geometry = new PlaneGeometry(bboxSize.x, bboxSize.z, 1, 1);
    geometry.rotateX(- Math.PI / 2);
    geometry.rotateY(- Math.PI / 2);

    const material = new MeshStandardMaterial({
        color: new Color(COLOUR_SELECTED),
        visible: true,
        opacity: 0.4,
    });

    const ghost = new Mesh(geometry, material);
    ghost.name = "ghost";
    ghost.receiveShadow = true;
    ghost.position.set(-0.1, 0, 0);
    scene.value.add(ghost);
});
</script>

<template>
    <slot></slot>
</template>

Model.ts
import { Mesh, Vector3, Scene, Group, MeshToonMaterial, Color, type Object3DEventMap, MeshBasicMaterial, BoxHelper, Box3 } from "three";
import { type GLTF, GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';


export class Model extends Mesh {

  scaleRatio: number;
  pos: Vector3;

  group?: Group;
  modelScene?: Group<Object3DEventMap>;
  mesh?: Mesh;
  move?: boolean;

  boundingBox?: Box3;
  boxHelper?: BoxHelper;

  gltfUrl: string;


  constructor(name: string, pos: Vector3, scaleRatio: number, gltfUrl: string) {
    super()

    this.name = name;
    this.scaleRatio = scaleRatio;
    this.pos = pos;

    this.gltfUrl = gltfUrl;
  }

  changeColour(colour: string) {
    if (!this.modelScene)
      return;

    this.modelScene.traverse((child: any) => {
      if (child.isMesh) {
        if (!child.name.toLowerCase().includes("outline")) {
          (child.material as MeshToonMaterial).color = new Color(colour);
        }
      }
    });
  }

  async initMesh(): Promise<Group<Object3DEventMap>> {
    const loader = new GLTFLoader();

    return new Promise((resolve, reject) => {
      loader.load(
        this.gltfUrl,
        (gltf: GLTF) => {
          this.modelScene = gltf.scene;

          const parameters = {
            color: new Color(0xe2eab8),
          };

          const matToon = new MeshToonMaterial(parameters);
          matToon.opacity = 0.005;
          const matColor = new MeshBasicMaterial({ color: 0x3c3c3c });

          gltf.scene.traverse((child: any) => {
            if (child.isMesh) {
              child.geometry.computeBoundingBox();
            }

            if (child.name.toLowerCase().includes("outline")) {
              child.material = matColor;
            } else {
              child.material = matToon;
              child.castShadow = true;
            }

            child.name += "_model";
          });

          this.modelScene.name = "root_model";
          this.modelScene.scale.multiplyScalar(this.scaleRatio);
          this.modelScene.position.set(this.pos.x, this.pos.y, this.pos.z);

          // this.boxHelper = new BoxHelper(this.modelScene, 0xff0000);
          // this.boxHelper.name = "boxHelper_model";
          // this.boundingBox = new Box3().setFromObject(this.boxHelper);
          // this.boxHelper.update();

          // Update transforms for modelScene and its children
          this.modelScene.updateMatrixWorld(true);

          // Resolve the promise with the loaded model
          resolve(this.modelScene);
        },
        undefined,
        (error) => {
          console.error("Error loading model:", error);
          reject(error); // Reject the promise on error
        }
      );
    });
  }

  updateMatrix(delta?: number) {
    if (!delta)
      delta = 1;

    if (!this.modelScene)
      return;

    if (this.boxHelper) {
      this.boxHelper.position.set(this.modelScene.position.x * delta, this.modelScene.position.y * delta, this.modelScene.position.z * delta);
      this.boxHelper.update();
    }

    if (this.boundingBox)
      this.boundingBox.setFromObject(this.modelScene);
  }

  tick(delta?: number): void {
    if (!this.modelScene)
      return;

    this.updateMatrix(delta);
  }

}
